import numpy as np
from numpy import matrix
from math import pi,cos,sin
from IPython import embed

def SMC_Update(pose,opt,time,Ck):
	Lx=opt.Lx
	Ly=opt.Ly
	dt=opt.dt
	KX=opt.ergKX
	KY=opt.ergKY
	HK=opt.ergHK
	muk=opt.ergmuk
	LK=opt.ergLK

	for iagent in range(0,opt.nagents):
		xrel=pose.x[iagent]-opt.xmin
		yrel=pose.y[iagent]-opt.ymin
		
		Ck=Ck+np.divide(np.multiply(np.cos((KX)*(pi)*(xrel/Lx)),np.cos(KY*pi*yrel/Ly))*dt,HK.T)
		
	
	temp=np.multiply(np.divide(LK,HK.T),Ck-opt.nagents*time*muk)	
	
	for i in range(0,opt.nagents):
		xrel=pose.x[i]-opt.xmin
		yrel=pose.y[i]-opt.ymin

		Bjx=(np.multiply(temp,np.multiply(np.multiply(-KX*pi/Lx,np.sin(KX*pi*xrel/Lx)),np.cos(KY*pi*yrel/Ly)))).sum()
		Bjy=(np.multiply(temp,np.multiply(np.multiply(-KY*pi/Ly,np.cos(KX*pi*xrel/Lx)),np.sin(KY*pi*yrel/Ly)))).sum()
		
		GammaV=Bjx*cos(pose.theta[i])+Bjy*sin(pose.theta[i])
		GammaW=-Bjx*sin(pose.theta[i])+Bjy*cos(pose.theta[i])

		if GammaV >= 0:
			v=opt.vlb[i]
		else:
			v=opt.vub[i]
		if GammaW >= 0 :
			w=opt.wlb[i]
		else :
			w=opt.wub[i]
		
		if abs(w)< 1e-10 :
			pose.x[i] = pose.x[i] + v*dt*cos(pose.theta[i]);   
        	pose.y[i] = pose.y[i] + v*dt*sin(pose.theta[i]);
        else:
        	pose.x[i] = pose.x[i] + (v/w)*(sin(pose.theta[i] + w*dt) - sin(pose.theta[i]));   
        	pose.y[i] = pose.y[i] + (v/w)*(cos(pose.theta[i]) - cos(pose.theta[i]+ w*dt));		
				

   		pose.theta[i]=pose.theta[i]+ w*dt
   		

	return 	pose,Ck	

			


